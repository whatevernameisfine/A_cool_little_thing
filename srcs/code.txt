/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   colors.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: riramana <riramana@student.42antananari    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/28 15:30:00 by riramana          #+#    #+#             */
/*   Updated: 2025/07/30 16:20:48 by riramana         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/fractol.h"

int	get_color(int iter)
{
	if (iter == MAX_ITER)
		return (0x000000);
	return (get_color_scheme_0(iter));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   colors_bonus.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: riramana <riramana@student.42antananarivo  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/29 09:18:09 by riramana          #+#    #+#             */
/*   Updated: 2025/07/29 10:53:23 by riramana         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/fractol_bonus.h"

static int	get_color_scheme_345(int iter, int color_shift)
{
	int	r;
	int	g;
	int	b;

	if (color_shift == 3)
	{
		r = (255 - (iter * 5) % 256);
		g = (iter * 7) % 256;
		b = (iter * 11) % 256;
	}
	else if (color_shift == 4)
	{
		r = (iter * 3) % 256;
		g = (255 - (iter * 6) % 256);
		b = (iter * 12) % 256;
	}
	else
	{
		r = (iter * 8) % 256;
		g = (iter * 4) % 256;
		b = (255 - (iter * 10) % 256);
	}
	return (r << 16 | g << 8 | b);
}

int	get_color(int iter, int color_shift)
{
	if (iter == MAX_ITER)
		return (0x000000);
	if (color_shift == 0)
		return (get_color_scheme_0(iter));
	else if (color_shift == 1)
		return (get_color_scheme_1(iter));
	else if (color_shift == 2)
		return (get_color_scheme_2(iter));
	else
		return (get_color_scheme_345(iter, color_shift));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   fractals.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: riramana <riramana@student.42antananarivo  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/30 13:41:33 by riramana          #+#    #+#             */
/*   Updated: 2025/07/29 10:53:30 by riramana         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/fractol.h"

int	mandelbrot_at(int x, int y, t_data *data)
{
	t_complex	c;
	double		zr2;
	double		zi2;

	c.cr = MIN_RE + x * ((MAX_RE - MIN_RE) / data->width);
	c.ci = MIN_IM + y * ((MAX_IM - MIN_IM) / data->height);
	c.cr = (c.cr - (MAX_RE + MIN_RE) / 2.0) / data->zoom + data->offset_x;
	c.ci = (c.ci - (MAX_IM + MIN_IM) / 2.0) / data->zoom + data->offset_y;
	c.zr = 0.0;
	c.zi = 0.0;
	c.iter = 0;
	while (c.iter < MAX_ITER)
	{
		zr2 = c.zr * c.zr;
		zi2 = c.zi * c.zi;
		if ((zr2 + zi2) > 4.0)
			break ;
		c.zi = 2.0 * c.zr * c.zi + c.ci;
		c.zr = zr2 - zi2 + c.cr;
		c.iter++;
	}
	return (c.iter);
}

int	julia_at(int x, int y, t_data *data)
{
	t_complex	z;
	double		zr2;
	double		zi2;
	int			iter;

	z.zr = MIN_RE + x * ((MAX_RE - MIN_RE) / data->width);
	z.zi = MIN_IM + y * ((MAX_IM - MIN_IM) / data->height);
	z.zr = (z.zr - (MAX_RE + MIN_RE) / 2.0) / data->zoom + data->offset_x;
	z.zi = (z.zi - (MAX_IM + MIN_IM) / 2.0) / data->zoom + data->offset_y;
	z.cr = data->julia_re;
	z.ci = data->julia_im;
	iter = 0;
	while (iter < MAX_ITER)
	{
		zr2 = z.zr * z.zr;
		zi2 = z.zi * z.zi;
		if ((zr2 + zi2) > 4.0)
			break ;
		z.zi = 2.0 * z.zr * z.zi + z.ci;
		z.zr = zr2 - zi2 + z.cr;
		iter++;
	}
	return (iter);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   fractals_bonus.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: riramana <riramana@student.42antananarivo  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/30 13:41:33 by riramana          #+#    #+#             */
/*   Updated: 2025/07/29 10:53:37 by riramana         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/fractol_bonus.h"
#include <math.h>

int	mandelbrot_at(int x, int y, t_data *data)
{
	t_complex	c;
	double		zr2;
	double		zi2;

	c.cr = MIN_RE + x * ((MAX_RE - MIN_RE) / data->width);
	c.ci = MIN_IM + y * ((MAX_IM - MIN_IM) / data->height);
	c.cr = (c.cr - (MAX_RE + MIN_RE) / 2.0) / data->zoom + data->offset_x;
	c.ci = (c.ci - (MAX_IM + MIN_IM) / 2.0) / data->zoom + data->offset_y;
	c.zr = 0.0;
	c.zi = 0.0;
	c.iter = 0;
	while (c.iter < MAX_ITER)
	{
		zr2 = c.zr * c.zr;
		zi2 = c.zi * c.zi;
		if ((zr2 + zi2) > 4.0)
			break ;
		c.zi = 2.0 * c.zr * c.zi + c.ci;
		c.zr = zr2 - zi2 + c.cr;
		c.iter++;
	}
	return (c.iter);
}

int	julia_at(int x, int y, t_data *data)
{
	t_complex	z;
	double		zr2;
	double		zi2;
	int			iter;

	z.zr = MIN_RE + x * ((MAX_RE - MIN_RE) / data->width);
	z.zi = MIN_IM + y * ((MAX_IM - MIN_IM) / data->height);
	z.zr = (z.zr - (MAX_RE + MIN_RE) / 2.0) / data->zoom + data->offset_x;
	z.zi = (z.zi - (MAX_IM + MIN_IM) / 2.0) / data->zoom + data->offset_y;
	z.cr = data->julia_re;
	z.ci = data->julia_im;
	iter = 0;
	while (iter < MAX_ITER)
	{
		zr2 = z.zr * z.zr;
		zi2 = z.zi * z.zi;
		if ((zr2 + zi2) > 4.0)
			break ;
		z.zi = 2.0 * z.zr * z.zi + z.ci;
		z.zr = zr2 - zi2 + z.cr;
		iter++;
	}
	return (iter);
}

int	burning_ship_at(int x, int y, t_data *data)
{
	t_complex	c;
	double		zr2;
	double		zi2;

	c.cr = MIN_RE + x * ((MAX_RE - MIN_RE) / data->width);
	c.ci = MIN_IM + y * ((MAX_IM - MIN_IM) / data->height);
	c.cr = (c.cr - (MAX_RE + MIN_RE) / 2.0) / data->zoom + data->offset_x;
	c.ci = (c.ci - (MAX_IM + MIN_IM) / 2.0) / data->zoom + data->offset_y;
	c.zr = 0.0;
	c.zi = 0.0;
	c.iter = 0;
	while (c.iter < MAX_ITER)
	{
		zr2 = c.zr * c.zr;
		zi2 = c.zi * c.zi;
		if ((zr2 + zi2) > 4.0)
			break ;
		c.zi = 2.0 * fabs(c.zr) * fabs(c.zi) + c.ci;
		c.zr = zr2 - zi2 + c.cr;
		c.iter++;
	}
	return (c.iter);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   fractol.h                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: riramana <riramana@student.42antananarivo  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/30 13:22:00 by riramana          #+#    #+#             */
/*   Updated: 2025/08/23 13:45:00 by riramana         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef FRACTOL_H
# define FRACTOL_H

# include <unistd.h>
# include <stdlib.h>

# define MIN_RE -2.0
# define MAX_RE 2.0
# define MIN_IM -2.0
# define MAX_IM 2.0
# define MAX_ITER 100

typedef struct s_complex
{
	double	cr;
	double	ci;
	double	zr;
	double	zi;
	int		iter;
}	t_complex;

typedef struct s_data
{
	void	*mlx;
	void	*window;
	void	*img;
	char	*img_data;
	int		bits_per_pixel;
	int		line_length;
	int		endian;
	int		width;
	int		height;
	double	zoom;
	double	offset_x;
	double	offset_y;
	int		fractal_type;
	double	julia_re;
	double	julia_im;
}	t_data;

// Existing function declarations
int		ft_strcmp(char *s1, char *s2);
void	init_data(t_data *data);
void	draw_fractal(t_data *data);
int		mandelbrot_at(int x, int y, t_data *data);
int		julia_at(int x, int y, t_data *data);
int		get_color(int iter);
int		get_color_scheme_0(int iter);
int		handle_keypress(int keycode, t_data *data);
int		handle_close(t_data *data);
int		handle_mouse(int button, int x, int y, t_data *data);
int		is_valid_double(char *str);
double	ft_atod(char *str);
void	put_pixel_to_image(t_data *data, int x, int y, int color);
int		init_image(t_data *data);

// New multithreading function
void	draw_fractal_threaded(t_data *data);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   fractol_bonus.h                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: riramana <riramana@student.42antananarivo  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/30 13:22:00 by riramana          #+#    #+#             */
/*   Updated: 2025/08/23 13:45:00 by riramana         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef FRACTOL_BONUS_H
# define FRACTOL_BONUS_H

# include <unistd.h>
# include <stdlib.h>

# define MIN_RE -2.0
# define MAX_RE 2.0
# define MIN_IM -2.0
# define MAX_IM 2.0
# define MAX_ITER 100

typedef struct s_complex
{
	double	cr;
	double	ci;
	double	zr;
	double	zi;
	int		iter;
}	t_complex;

typedef struct s_data
{
	void	*mlx;
	void	*window;
	void	*img;
	char	*img_data;
	int		bits_per_pixel;
	int		line_length;
	int		endian;
	int		width;
	int		height;
	double	zoom;
	double	offset_x;
	double	offset_y;
	int		fractal_type;
	double	julia_re;
	double	julia_im;
	int		move_up;
	int		move_down;
	int		move_left;
	int		move_right;
	int		color_shift;
	int		mouse_x;
	int		mouse_y;
}	t_data;

// Existing function declarations
int		ft_strcmp(char *s1, char *s2);
void	init_data(t_data *data);
void	draw_fractal(t_data *data);
int		mandelbrot_at(int x, int y, t_data *data);
int		julia_at(int x, int y, t_data *data);
int		burning_ship_at(int x, int y, t_data *data);
int		get_color(int iter, int color_shift);
int		get_color_scheme_0(int iter);
int		get_color_scheme_1(int iter);
int		get_color_scheme_2(int iter);
int		handle_keypress(int keycode, t_data *data);
int		handle_keyrelease(int keycode, t_data *data);
int		handle_frame(t_data *data);
int		handle_close(t_data *data);
int		handle_mouse(int button, int x, int y, t_data *data);
int		handle_mouse_move(int x, int y, t_data *data);
int		is_valid_double(char *str);
double	ft_atod(char *str);
void	put_pixel_to_image(t_data *data, int x, int y, int color);
int		init_image(t_data *data);
void	write_usage(void);
int		init_window(t_data *data);

// New multithreading function
void	draw_fractal_threaded(t_data *data);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   hooks.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: riramana <riramana@student.42antananari    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/30 14:11:39 by riramana          #+#    #+#             */
/*   Updated: 2025/07/30 16:28:46 by riramana         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/fractol.h"
#include "../minilibx-linux/mlx.h"

int	handle_close(t_data *data)
{
	if (data->img)
		mlx_destroy_image(data->mlx, data->img);
	mlx_destroy_window(data->mlx, data->window);
	mlx_destroy_display(data->mlx);
	free(data->mlx);
	exit(0);
	return (0);
}

int	handle_keypress(int keycode, t_data *data)
{
	if (keycode == 65307)
		handle_close(data);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   hooks_bonus.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: riramana <riramana@student.42antananarivo  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/30 14:11:39 by riramana          #+#    #+#             */
/*   Updated: 2025/07/29 10:53:46 by riramana         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/fractol_bonus.h"

static void	move_view(t_data *data, double speed, int *moved)
{
	if (data->move_up)
	{
		data->offset_y -= speed;
		*moved = 1;
	}
	if (data->move_down)
	{
		data->offset_y += speed;
		*moved = 1;
	}
	if (data->move_left)
	{
		data->offset_x -= speed;
		*moved = 1;
	}
	if (data->move_right)
	{
		data->offset_x += speed;
		*moved = 1;
	}
}

int	handle_keypress(int keycode, t_data *data)
{
	if (keycode == 65307)
		handle_close(data);
	if (keycode == 65362)
		data->move_up = 1;
	if (keycode == 65364)
		data->move_down = 1;
	if (keycode == 65361)
		data->move_left = 1;
	if (keycode == 65363)
		data->move_right = 1;
	if (keycode == 99)
	{
		data->color_shift = (data->color_shift + 1) % 6;
		draw_fractal(data);
	}
	return (0);
}

int	handle_keyrelease(int keycode, t_data *data)
{
	if (keycode == 65362)
		data->move_up = 0;
	if (keycode == 65364)
		data->move_down = 0;
	if (keycode == 65361)
		data->move_left = 0;
	if (keycode == 65363)
		data->move_right = 0;
	return (0);
}

int	handle_frame(t_data *data)
{
	int		moved;
	double	speed;

	moved = 0;
	speed = 0.1 / data->zoom;
	move_view(data, speed, &moved);
	if (moved)
		draw_fractal(data);
	return (0);
}

int	handle_mouse_move(int x, int y, t_data *data)
{
	data->mouse_x = x;
	data->mouse_y = y;
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: riramana <riramana@student.42antananari    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/30 13:21:56 by riramana          #+#    #+#             */
/*   Updated: 2025/08/24 08:02:00 by copilot          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/fractol.h"
#include "../minilibx-linux/mlx.h"
#include <unistd.h>

static int	validate_julia_args(char **argv, t_data *data)
{
	ssize_t ignored;
	if (!is_valid_double(argv[2]) || !is_valid_double(argv[3]))
	{
		ignored = write(1, "Error: Invalid number format\n", 29);
		(void)ignored;
		ignored = write(1, "Usage: ./fractol julia <real> <imag>\n", 37);
		(void)ignored;
		return (1);
	}
	data->julia_re = ft_atod(argv[2]);
	data->julia_im = ft_atod(argv[3]);
	return (0);
}

static int	handle_julia(t_data *data, int argc, char **argv)
{
	ssize_t ignored;
	data->fractal_type = 2;
	if (argc == 4)
	{
		return (validate_julia_args(argv, data));
	}
	else if (argc == 2)
	{
		data->julia_re = -0.8;
		data->julia_im = 0.156;
	}
	else
	{
		ignored = write(1, "Usage:\n ./fractol julia <real> <imag>\n", 39);
		(void)ignored;
		return (1);
	}
	return (0);
}

static int	parse_args(t_data *data, int argc, char **argv)
{
	ssize_t ignored;
	if (argc >= 2 && ft_strcmp(argv[1], "mandelbrot") == 0)
	{
		if (argc != 2)
		{
			ignored = write(1, "Usage:\n  ./fractol mandelbrot\n", 30);
			(void)ignored;
			return (1);
		}
		data->fractal_type = 1;
		return (0);
	}
	else if (argc >= 2 && ft_strcmp(argv[1], "julia") == 0)
	{
		return (handle_julia(data, argc, argv));
	}
	ignored = write(1, "Usage:\n  ./fractol mandelbrot\n", 31);
	(void)ignored;
	ignored = write(1, "  ./fractol julia [<real> <imag>]\n", 33);
	(void)ignored;
	return (1);
}

static int	init_window(t_data *data)
{
	char	*title;

	if (data->fractal_type == 1)
		title = "mandelbrot";
	else
		title = "julia";
	data->mlx = mlx_init();
	if (!data->mlx)
		return (1);
	data->window = mlx_new_window(data->mlx, data->width, data->height, title);
	if (!data->window)
		return (1);
	return (init_image(data));
}

int	main(int argc, char **argv)
{
	t_data	data;

	if (parse_args(&data, argc, argv))
		return (1);
	init_data(&data);
	if (init_window(&data))
		return (1);
	draw_fractal(&data);
	mlx_hook(data.window, 2, 1L << 0, handle_keypress, &data);
	mlx_mouse_hook(data.window, handle_mouse, &data);
	mlx_hook(data.window, 17, 0, handle_close, &data);
	mlx_loop(data.mlx);
	return (0);
}
#include "../includes/fractol_bonus.h"
#include "../minilibx-linux/mlx.h"
#include <unistd.h>

static int	validate_julia_args(char **argv, t_data *data)
{
	ssize_t ignored;
	if (!is_valid_double(argv[2]) || !is_valid_double(argv[3]))
	{
		ignored = write(1, "Error: Invalid number format\n", 29);
		(void)ignored;
		ignored = write(1, "Usage: ./fractol julia <real> <imag>\n", 37);
		(void)ignored;
		return (1);
	}
	data->julia_re = ft_atod(argv[2]);
	data->julia_im = ft_atod(argv[3]);
	return (0);
}

static int	handle_julia(t_data *data, int argc, char **argv)
{
	ssize_t ignored;
	data->fractal_type = 2;
	if (argc == 4)
	{
		return (validate_julia_args(argv, data));
	}
	else if (argc == 2)
	{
		data->julia_re = -0.8;
		data->julia_im = 0.156;
	}
	else
	{
		ignored = write(1, "Usage:\n ./fractol julia <real> <imag>\n", 39);
		(void)ignored;
		return (1);
	}
	return (0);
}

int	parse_args(t_data *data, int argc, char **argv)
{
	ssize_t ignored;
	if (argc >= 2 && ft_strcmp(argv[1], "mandelbrot") == 0)
	{
		if (argc != 2)
		{
			ignored = write(1, "Usage:\n  ./fractol mandelbrot\n", 30);
			(void)ignored;
			return (1);
		}
		data->fractal_type = 1;
		return (0);
	}
	else if (argc >= 2 && ft_strcmp(argv[1], "julia") == 0)
	{
		return (handle_julia(data, argc, argv));
	}
	ignored = write(1, "Usage:\n  ./fractol mandelbrot\n", 31);
	(void)ignored;
	ignored = write(1, "  ./fractol julia [<real> <imag>]\n", 33);
	(void)ignored;
	return (1);
}

int main(int argc, char **argv)
{
	t_data	data;

	if (parse_args(&data, argc, argv))
		return (1);
	init_data(&data);
	if (init_window(&data))
		return (1);
	mlx_hook(data.window, 2, 1L << 0, handle_keypress, &data);
	mlx_hook(data.window, 3, 1L << 1, handle_keyrelease, &data); // ADD THIS LINE
	mlx_mouse_hook(data.window, handle_mouse, &data);
	mlx_hook(data.window, 17, 0, handle_close, &data);
	mlx_loop_hook(data.mlx, handle_frame, &data);
	mlx_loop(data.mlx);
	return (0);
}
# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    Makefile                                           :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: riramana <riramana@student.42antananarivo  +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2025/06/30 13:20:00 by riramana          #+#    #+#              #
#    Updated: 2025/08/23 13:45:00 by riramana         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

NAME = fractol
BONUS_NAME = fractol_bonus

CC = cc
CFLAGS = -Wall -Wextra -Werror -O3
LIBS = -Lminilibx-linux -lmlx -lXext -lX11 -lm -lpthread

SRCDIR = srcs
OBJDIR = obj
INCDIR = includes

SOURCES = main.c utils.c utils_2.c utils_3.c colors.c fractals.c hooks.c mouse_utils.c utils_multithreading.c
BONUS_SOURCES = main_bonus.c utils_bonus.c utils_2_bonus.c utils_3_bonus.c colors_bonus.c fractals_bonus.c hooks_bonus.c mouse_utils_bonus.c utils_multithreading_bonus.c

SRCS = $(addprefix $(SRCDIR)/, $(SOURCES))
BONUS_SRCS = $(addprefix $(SRCDIR)/, $(BONUS_SOURCES))

OBJS = $(addprefix $(OBJDIR)/, $(SOURCES:.c=.o))
BONUS_OBJS = $(addprefix $(OBJDIR)/, $(BONUS_SOURCES:.c=.o))

# Default target
all: $(NAME)

# Linking
$(NAME): $(OBJS)
	$(CC) $(CFLAGS) $(OBJS) $(LIBS) -o $(NAME)

$(BONUS_NAME): $(BONUS_OBJS)
	$(CC) $(CFLAGS) $(BONUS_OBJS) $(LIBS) -o $(BONUS_NAME)

# Compilation pattern
$(OBJDIR)/%.o: $(SRCDIR)/%.c | $(OBJDIR)
	$(CC) $(CFLAGS) -I$(INCDIR) -c $< -o $@

# Create obj directory if not present
$(OBJDIR):
	mkdir -p $(OBJDIR)

# Targets
bonus: $(BONUS_NAME)

clean:
	rm -rf $(OBJDIR)

fclean: clean
	rm -f $(NAME) $(BONUS_NAME)

re: fclean all

.PHONY: all bonus clean fclean re
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   mouse_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: riramana <riramana@student.42antananari    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/28 15:45:00 by riramana          #+#    #+#             */
/*   Updated: 2025/07/30 13:48:56 by riramana         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/fractol.h"

int	handle_mouse(int button, int x, int y, t_data *data)
{
	double	zoom_factor;

	(void)x;
	(void)y;
	zoom_factor = 1.05;
	if (button == 4)
	{
		data->zoom *= zoom_factor;
		draw_fractal(data);
	}
	else if (button == 5)
	{
		data->zoom /= zoom_factor;
		if (data->zoom < 0.01)
			data->zoom = 0.01;
		draw_fractal(data);
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   mouse_utils_bonus.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: riramana <riramana@student.42antananarivo  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/28 15:45:00 by riramana          #+#    #+#             */
/*   Updated: 2025/07/29 10:54:03 by riramana         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/fractol_bonus.h"

static void	calculate_mouse_coords(int x, int y, t_data *data, double coords[2])
{
	coords[0] = MIN_RE + x * ((MAX_RE - MIN_RE) / data->width);
	coords[1] = MIN_IM + y * ((MAX_IM - MIN_IM) / data->height);
	coords[0] = (coords[0] - (MAX_RE + MIN_RE) / 2.0) / data->zoom
		+ data->offset_x;
	coords[1] = (coords[1] - (MAX_IM + MIN_IM) / 2.0) / data->zoom
		+ data->offset_y;
}

static void	zoom_in(t_data *data, double mouse_re, double mouse_im,
		double zoom_factor)
{
	data->offset_x = mouse_re - (mouse_re - data->offset_x) / zoom_factor;
	data->offset_y = mouse_im - (mouse_im - data->offset_y) / zoom_factor;
	data->zoom *= zoom_factor;
}

static void	zoom_out(t_data *data, double mouse_re, double mouse_im,
		double zoom_factor)
{
	data->offset_x = mouse_re - (mouse_re - data->offset_x) * zoom_factor;
	data->offset_y = mouse_im - (mouse_im - data->offset_y) * zoom_factor;
	data->zoom /= zoom_factor;
}

int	handle_mouse(int button, int x, int y, t_data *data)
{
	double	coords[2];
	double	zoom_factor;

	zoom_factor = 1.05;
	if (button == 4 || button == 5)
	{
		calculate_mouse_coords(x, y, data, coords);
		if (button == 4)
			zoom_in(data, coords[0], coords[1], zoom_factor);
		else if (button == 5)
			zoom_out(data, coords[0], coords[1], zoom_factor);
		if (data->zoom < 0.01)
			data->zoom = 0.01;
		draw_fractal(data);
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: riramana <riramana@student.42antananari    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/30 14:56:27 by riramana          #+#    #+#             */
/*   Updated: 2025/08/23 13:45:00 by riramana         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/fractol.h"

int	ft_strcmp(char *s1, char *s2)
{
	int	i;

	i = 0;
	while ((s1[i] == s2[i]) && s1[i] && s2[i])
		i++;
	return (s1[i] - s2[i]);
}

void	init_data(t_data *data)
{
	data->zoom = 1.0;
	data->offset_x = 0.0;
	data->offset_y = 0.0;
	data->width = 800;
	data->height = 800;
	data->img = NULL;
	data->img_data = NULL;
}

void	draw_fractal(t_data *data)
{
	draw_fractal_threaded(data);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils_2.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: riramana <riramana@student.42antananari    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/30 15:35:45 by riramana          #+#    #+#             */
/*   Updated: 2025/07/30 18:39:37 by riramana         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/fractol.h"

static int	validate_number_format(char *str, int *i, int *has_digit_before_dot)
{
	int	has_digit_after_dot;
	int	has_dot;

	has_digit_after_dot = 0;
	has_dot = 0;
	while (str[*i] >= '0' && str[*i] <= '9')
	{
		*has_digit_before_dot = 1;
		(*i)++;
	}
	if (str[*i] == '.')
	{
		has_dot = 1;
		(*i)++;
		while (str[*i] >= '0' && str[*i] <= '9')
		{
			has_digit_after_dot = 1;
			(*i)++;
		}
	}
	if (str[*i] != '\0')
		return (0);
	if (has_dot)
		return (*has_digit_before_dot && has_digit_after_dot);
	return (*has_digit_before_dot);
}

int	is_valid_double(char *str)
{
	int	i;
	int	has_digit_before_dot;

	if (!str || !*str)
		return (0);
	i = 0;
	has_digit_before_dot = 0;
	while (str[i] == ' ' || (str[i] >= 9 && str[i] <= 13))
		i++;
	if (str[i] == '-' || str[i] == '+')
		i++;
	return (validate_number_format(str, &i, &has_digit_before_dot));
}

static int	parse_integer_part(char *str, int *i, int *sign)
{
	int	value;

	*i = 0;
	*sign = 1;
	value = 0;
	while (str[*i] == ' ' || (str[*i] >= 9 && str[*i] <= 13))
		(*i)++;
	if (str[*i] == '-' || str[*i] == '+')
	{
		if (str[*i] == '-')
			*sign = -1;
		(*i)++;
	}
	while (str[*i] >= '0' && str[*i] <= '9')
	{
		value = value * 10 + (str[*i] - '0');
		(*i)++;
	}
	return (value);
}

double	ft_atod(char *str)
{
	int		i;
	int		sign;
	double	result;
	double	frac;

	if (!is_valid_double(str))
		return (0.0);
	result = parse_integer_part(str, &i, &sign);
	frac = 0.1;
	if (str[i] == '.')
	{
		i++;
		while (str[i] >= '0' && str[i] <= '9')
		{
			result += (str[i] - '0') * frac;
			frac *= 0.1;
			i++;
		}
	}
	return (sign * result);
}

void	put_pixel_to_image(t_data *data, int x, int y, int color)
{
	char	*dst;

	if (x >= 0 && x < data->width && y >= 0 && y < data->height)
	{
		dst = data->img_data + (y * data->line_length + x
				* (data->bits_per_pixel / 8));
		*(unsigned int *)dst = color;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils_2.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: riramana <riramana@student.42antananarivo  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/30 15:35:45 by riramana          #+#    #+#             */
/*   Updated: 2025/07/29 10:54:14 by riramana         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/fractol.h"

static int	validate_number_format(char *str, int *i, int *has_digit_before_dot)
{
	int	has_digit_after_dot;
	int	has_dot;

	has_digit_after_dot = 0;
	has_dot = 0;
	while (str[*i] >= '0' && str[*i] <= '9')
	{
		*has_digit_before_dot = 1;
		(*i)++;
	}
	if (str[*i] == '.')
	{
		has_dot = 1;
		(*i)++;
		while (str[*i] >= '0' && str[*i] <= '9')
		{
			has_digit_after_dot = 1;
			(*i)++;
		}
	}
	if (str[*i] != '\0')
		return (0);
	if (has_dot)
		return (*has_digit_before_dot && has_digit_after_dot);
	return (*has_digit_before_dot);
}

int	is_valid_double(char *str)
{
	int	i;
	int	has_digit_before_dot;

	if (!str || !*str)
		return (0);
	i = 0;
	has_digit_before_dot = 0;
	while (str[i] == ' ' || (str[i] >= 9 && str[i] <= 13))
		i++;
	if (str[i] == '-' || str[i] == '+')
		i++;
	return (validate_number_format(str, &i, &has_digit_before_dot));
}

static int	parse_integer_part(char *str, int *i, int *sign)
{
	int	value;

	*i = 0;
	*sign = 1;
	value = 0;
	while (str[*i] == ' ' || (str[*i] >= 9 && str[*i] <= 13))
		(*i)++;
	if (str[*i] == '-' || str[*i] == '+')
	{
		if (str[*i] == '-')
			*sign = -1;
		(*i)++;
	}
	while (str[*i] >= '0' && str[*i] <= '9')
	{
		value = value * 10 + (str[*i] - '0');
		(*i)++;
	}
	return (value);
}

double	ft_atod(char *str)
{
	int		i;
	int		sign;
	double	result;
	double	frac;

	if (!is_valid_double(str))
		return (0.0);
	result = parse_integer_part(str, &i, &sign);
	frac = 0.1;
	if (str[i] == '.')
	{
		i++;
		while (str[i] >= '0' && str[i] <= '9')
		{
			result += (str[i] - '0') * frac;
			frac *= 0.1;
			i++;
		}
	}
	return (sign * result);
}

void	put_pixel_to_image(t_data *data, int x, int y, int color)
{
	char	*dst;

	if (x >= 0 && x < data->width && y >= 0 && y < data->height)
	{
		dst = data->img_data + (y * data->line_length + x
				* (data->bits_per_pixel / 8));
		*(unsigned int *)dst = color;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils_3.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: riramana <riramana@student.42antananari    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/28 15:00:00 by riramana          #+#    #+#             */
/*   Updated: 2025/07/30 18:24:45 by riramana         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/fractol.h"
#include "../minilibx-linux/mlx.h"

int	init_image(t_data *data)
{
	data->img = mlx_new_image(data->mlx, data->width, data->height);
	if (!data->img)
		return (1);
	data->img_data = mlx_get_data_addr(data->img, &data->bits_per_pixel,
			&data->line_length, &data->endian);
	if (!data->img_data)
		return (1);
	return (0);
}

int	get_color_scheme_0(int iter)
{
	int	r;
	int	g;
	int	b;

	r = (iter * 9) % 256;
	g = (iter * 2) % 256;
	b = (iter * 15) % 256;
	return (r << 16 | g << 8 | b);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils_3_bonus.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: riramana <riramana@student.42antananarivo  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/07/28 15:00:00 by riramana          #+#    #+#             */
/*   Updated: 2025/07/29 10:54:21 by riramana         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/fractol_bonus.h"
#include "../minilibx-linux/mlx.h"

void	write_usage(void)
{
	ssize_t ignored;

	ignored = write(1, "Usage:\n  ./fractol mandelbrot\n", 31);
	(void)ignored;
	ignored = write(1, "  ./fractol julia [<real> <imag>]\n", 33);
	(void)ignored;
	ignored = write(1, "  ./fractol burning_ship\n", 24);
	(void)ignored;
}

int	init_image(t_data *data)
{
	data->img = mlx_new_image(data->mlx, data->width, data->height);
	if (!data->img)
		return (1);
	data->img_data = mlx_get_data_addr(data->img, &data->bits_per_pixel,
			&data->line_length, &data->endian);
	if (!data->img_data)
		return (1);
	return (0);
}

int	get_color_scheme_0(int iter)
{
	int	r;
	int	g;
	int	b;

	r = (iter * 9) % 256;
	g = (iter * 2) % 256;
	b = (iter * 15) % 256;
	return (r << 16 | g << 8 | b);
}

int	get_color_scheme_1(int iter)
{
	int	r;
	int	g;
	int	b;

	r = (iter * 15) % 256;
	g = (iter * 9) % 256;
	b = (iter * 2) % 256;
	return (r << 16 | g << 8 | b);
}

int	get_color_scheme_2(int iter)
{
	int	r;
	int	g;
	int	b;

	r = (iter * 2) % 256;
	g = (iter * 15) % 256;
	b = (iter * 9) % 256;
	return (r << 16 | g << 8 | b);
}
int	init_window(t_data *data)
{
	char	*title;

	if (data->fractal_type == 1)
		title = "mandelbrot";
	else if (data->fractal_type == 2)
		title = "julia";
	else
		title = "burning_ship";
	data->mlx = mlx_init();
	if (!data->mlx)
		return (1);
	data->window = mlx_new_window(data->mlx, data->width, data->height, title);
	if (!data->window)
		return (1);
	return (init_image(data));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils_bonus.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: riramana <riramana@student.42antananari    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/06/30 14:56:27 by riramana          #+#    #+#             */
/*   Updated: 2025/08/23 13:45:00 by riramana         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/fractol_bonus.h"
#include "../minilibx-linux/mlx.h"

void	init_data(t_data *data)
{
	data->zoom = 1.0;
	data->offset_x = 0.0;
	data->offset_y = 0.0;
	data->move_up = 0;
	data->move_down = 0;
	data->move_left = 0;
	data->move_right = 0;
	data->width = 800;
	data->height = 800;
	data->img = NULL;
	data->img_data = NULL;
	data->color_shift = 0;
	data->mouse_x = 0;
	data->mouse_y = 0;
}

int	handle_close(t_data *data)
{
	if (data->img)
		mlx_destroy_image(data->mlx, data->img);
	mlx_destroy_window(data->mlx, data->window);
	mlx_destroy_display(data->mlx);
	free(data->mlx);
	exit(0);
	return (0);
}

int	ft_strcmp(char *s1, char *s2)
{
	int	i;

	i = 0;
	while ((s1[i] == s2[i]) && s1[i] && s2[i])
		i++;
	return (s1[i] - s2[i]);
}

void	draw_fractal(t_data *data)
{
	draw_fractal_threaded(data);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils_multithreading.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: riramana <riramana@student.42antananarivo  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/23 13:45:00 by riramana          #+#    #+#             */
/*   Updated: 2025/08/23 13:45:00 by riramana         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/fractol.h"
#include "../minilibx-linux/mlx.h"
#include <pthread.h>
#include <unistd.h>

#define NUM_THREADS 8

typedef struct s_thread_data
{
	t_data	*data;
	int		start_y;
	int		end_y;
	int		thread_id;
}	t_thread_data;

static void	*render_section(void *arg)
{
	t_thread_data	*thread_data;
	int				x;
	int				y;
	int				iter;
	int				color;

	thread_data = (t_thread_data *)arg;
	y = thread_data->start_y;
	while (y < thread_data->end_y)
	{
		x = 0;
		while (x < thread_data->data->width)
		{
			if (thread_data->data->fractal_type == 1)
				iter = mandelbrot_at(x, y, thread_data->data);
			else
				iter = julia_at(x, y, thread_data->data);
			color = get_color(iter);
			put_pixel_to_image(thread_data->data, x, y, color);
			x++;
		}
		y++;
	}
	return (NULL);
}

void	draw_fractal_threaded(t_data *data)
{
	pthread_t		threads[NUM_THREADS];
	t_thread_data	thread_data[NUM_THREADS];
	int				rows_per_thread;
	int				i;

	rows_per_thread = data->height / NUM_THREADS;
	i = 0;
	while (i < NUM_THREADS)
	{
		thread_data[i].data = data;
		thread_data[i].start_y = i * rows_per_thread;
		thread_data[i].end_y = (i == NUM_THREADS - 1) ? 
			data->height : (i + 1) * rows_per_thread;
		thread_data[i].thread_id = i;
		pthread_create(&threads[i], NULL, render_section, &thread_data[i]);
		i++;
	}
	i = 0;
	while (i < NUM_THREADS)
	{
		pthread_join(threads[i], NULL);
		i++;
	}
	mlx_put_image_to_window(data->mlx, data->window, data->img, 0, 0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils_multithreading_bonus.c                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: riramana <riramana@student.42antananarivo  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/23 13:45:00 by riramana          #+#    #+#             */
/*   Updated: 2025/08/23 13:45:00 by riramana         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/fractol_bonus.h"
#include "../minilibx-linux/mlx.h"
#include <pthread.h>
#include <unistd.h>

#define NUM_THREADS 8

typedef struct s_thread_data
{
	t_data	*data;
	int		start_y;
	int		end_y;
	int		thread_id;
}	t_thread_data;

static void	*render_section_bonus(void *arg)
{
	t_thread_data	*thread_data;
	int				x;
	int				y;
	int				iter;
	int				color;

	thread_data = (t_thread_data *)arg;
	y = thread_data->start_y;
	while (y < thread_data->end_y)
	{
		x = 0;
		while (x < thread_data->data->width)
		{
			if (thread_data->data->fractal_type == 1)
				iter = mandelbrot_at(x, y, thread_data->data);
			else if (thread_data->data->fractal_type == 2)
				iter = julia_at(x, y, thread_data->data);
			else
				iter = burning_ship_at(x, y, thread_data->data);
			color = get_color(iter, thread_data->data->color_shift);
			put_pixel_to_image(thread_data->data, x, y, color);
			x++;
		}
		y++;
	}
	return (NULL);
}

void	draw_fractal_threaded(t_data *data)
{
	pthread_t		threads[NUM_THREADS];
	t_thread_data	thread_data[NUM_THREADS];
	int				rows_per_thread;
	int				i;

	rows_per_thread = data->height / NUM_THREADS;
	i = 0;
	while (i < NUM_THREADS)
	{
		thread_data[i].data = data;
		thread_data[i].start_y = i * rows_per_thread;
		thread_data[i].end_y = (i == NUM_THREADS - 1) ? 
			data->height : (i + 1) * rows_per_thread;
		thread_data[i].thread_id = i;
		pthread_create(&threads[i], NULL, render_section_bonus, &thread_data[i]);
		i++;
	}
	i = 0;
	while (i < NUM_THREADS)
	{
		pthread_join(threads[i], NULL);
		i++;
	}
	mlx_put_image_to_window(data->mlx, data->window, data->img, 0, 0);
}
